<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://stefaniezhao77.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://stefaniezhao77.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-04-06T19:32:43+00:00</updated><id>https://stefaniezhao77.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Converting a STEP File to MuJoCo XML for Physics Simulation: A Practical Guide</title><link href="https://stefaniezhao77.github.io/blog/2025/converting-a-step-file-to-mujoco-xml-for-physics-simulation-a-practical-guide/" rel="alternate" type="text/html" title="Converting a STEP File to MuJoCo XML for Physics Simulation: A Practical Guide"/><published>2025-04-06T19:06:15+00:00</published><updated>2025-04-06T19:06:15+00:00</updated><id>https://stefaniezhao77.github.io/blog/2025/converting-a-step-file-to-mujoco-xml-for-physics-simulation-a-practical-guide</id><content type="html" xml:base="https://stefaniezhao77.github.io/blog/2025/converting-a-step-file-to-mujoco-xml-for-physics-simulation-a-practical-guide/"><![CDATA[<p>Simulating a 3D CAD model in a physics engine like MuJoCo can be a powerful way to test designs in a virtual environment. However, MuJoCo doesn’t directly understand CAD formats like STEP (STP) files — it needs STL meshes and an XML file to define the simulation. In this blog, I’ll walk you through the process of converting a STEP file into a MuJoCo XML file using Python, focusing on the key steps, the reasoning behind them, and a real-world issue we encountered with shells and solids. Let’s get started!</p> <h3>Why Do This?</h3> <p>MuJoCo is a physics engine used for robotics, animation, and engineering simulations. It requires:</p> <ul><li><strong>STL Files</strong>: Triangle meshes that represent the 3D geometry of each part.</li><li><strong>XML File</strong>: A configuration file that links the STL meshes, defines their positions, and sets simulation properties like gravity and mass.</li></ul> <p>A STEP file, on the other hand, is a standard CAD format (ISO 10303) that stores precise 3D geometry using mathematical definitions (e.g., surfaces, solids). To use it in MuJoCo, we need to:</p> <ol><li>Extract the parts from the STEP file.</li><li>Convert them to STL meshes.</li><li>Create an XML file to tie everything together for simulation.</li></ol> <p>This process lets us take a CAD design — like our arch bridge — and simulate its physical behavior, such as how it handles stress or movement.</p> <h3>Key Terms: Understanding the STEP File</h3> <p>Before diving in, let’s clarify some terms you’ll encounter in a STEP file:</p> <ul><li><strong>Solid</strong>: A fully enclosed 3D volume with a defined interior, like a solid block or a closed frame. Solids are ideal for physics simulations because they have mass and volume.</li><li><strong>Shell</strong>: A collection of connected faces forming a surface, like the “skin” of an object. Shells don’t have an interior unless they’re part of a solid. They’re often used for thin-walled structures or reference geometry.</li><li><strong>Compound</strong>: A group of shapes (solids, shells, etc.) treated as a single entity in the STEP file. For example, a bridge might be a compound of multiple solids.</li></ul> <p>In our case, the ACDC_arch.stp file represents an arch bridge, which we expected to have 14 distinct segments (parts). However, as we’ll see, the STEP file’s structure caused an issue that we needed to resolve.</p> <h3>Tools You’ll Need</h3> <ul><li><strong>Python</strong>: Version 3.6+.</li><li><strong>Libraries</strong>:</li><li><strong>pythonocc-core</strong>: Reads STEP files and converts them to STL meshes.</li><li><strong>numpy</strong>: Handles numerical data for mesh creation.</li><li><strong>stl</strong>: Saves meshes as STL files.</li><li><strong>xml.etree.ElementTree</strong>: Builds the MuJoCo XML file.</li><li><strong>FreeCAD</strong>: A free CAD tool to inspect and modify the STEP file if needed.</li></ul> <p>Install the Python libraries:</p> <pre>pip install pythonocc-core numpy stl</pre> <h3>The Overall Process: Steps and Why</h3> <p>Here’s the high-level process to convert the STEP file to MuJoCo XML, along with why each step matters:</p> <p><strong>Extract Parts from the STEP File</strong>:</p> <ul><li><strong>Why</strong>: A STEP file can contain multiple parts (solids, shells, etc.), and we need to identify each one to convert it to STL. For our bridge, we expected 14 parts (one for each segment).</li><li><strong>How</strong>: Use pythonocc-core to read the STEP file and extract solids.</li></ul> <p><strong>Convert Parts to STL Files</strong>:</p> <ul><li><strong>Why</strong>: MuJoCo needs STL files (triangle meshes) to render and simulate the geometry. STEP files use mathematical surfaces, which MuJoCo can’t directly use.</li><li><strong>How</strong>: Tessellate each part into a mesh and save it as an STL file.</li></ul> <p><strong>Generate the MuJoCo XML File</strong>:</p> <ul><li><strong>Why</strong>: The XML file tells MuJoCo where to place each part, how they interact, and other simulation settings.</li><li><strong>How</strong>: Create an XML structure that references the STL files and defines the simulation environment.</li></ul> <h3>The Code: Key Steps</h3> <p>Here’s the simplified code to achieve this, focusing on the main ideas.</p> <h3>Step 1: Extract and Convert to STL</h3> <p>We use pythonocc-core to read the STEP file, extract solids, and convert them to STL files.</p> <pre>import os<br />from OCC.Core.STEPControl import STEPControl_Reader<br />from OCC.Core.TopExp import TopExp_Explorer, TopAbs_SOLID<br />from OCC.Core.BRepMesh import BRepMesh_IncrementalMesh<br />from OCC.Core.StlAPI import StlAPI_Writer<br />from OCC.Core.TopoDS import topods</pre> <pre>def extract_and_convert_stp_to_stl(stp_file_path, output_dir):<br />    os.makedirs(output_dir, exist_ok=True)<br />    step_reader = STEPControl_Reader()<br />    step_reader.ReadFile(stp_file_path)<br />    step_reader.TransferRoots()<br />    <br />    all_solids = []<br />    part_info = []<br />    for i in range(1, step_reader.NbRootsForTransfer() + 1):<br />        shape = step_reader.Shape(i)<br />        explorer = TopExp_Explorer(shape, TopAbs_SOLID)<br />        while explorer.More():<br />            solid = topods.Solid(explorer.Current())<br />            if solid not in all_solids:<br />                all_solids.append(solid)<br />                part_info.append({&#39;id&#39;: len(all_solids), &#39;name&#39;: f&#39;part_{len(all_solids)}&#39;})<br />            explorer.Next()<br />    <br />    print(f&quot;Detected {len(all_solids)} solids in the STEP file&quot;)<br />    <br />    successful_conversions = 0<br />    for i, solid in enumerate(all_solids):<br />        try:<br />            mesh = BRepMesh_IncrementalMesh(solid, 0.01)<br />            mesh.Perform()<br />            if not mesh.IsDone():<br />                continue<br />            stl_writer = StlAPI_Writer()<br />            stl_file = os.path.join(output_dir, f&quot;part_{i+1}.stl&quot;)<br />            stl_writer.Write(solid, stl_file)<br />            successful_conversions += 1<br />            print(f&quot;Created {stl_file}&quot;)<br />        except Exception as e:<br />            print(f&quot;Error processing part_{i+1}: {e}&quot;)<br />    <br />    return successful_conversions, part_info[:successful_conversions]</pre> <h3>Step 2: Generate MuJoCo XML</h3> <p>We create an XML file that references the STL files and sets up the simulation.</p> <pre>import xml.etree.ElementTree as ET<br />import xml.dom.minidom as minidom<br />import os</pre> <pre>def create_mujoco_xml(part_info, output_file, mesh_dir):<br />    root = ET.Element(&quot;mujoco&quot;, model=&quot;arch_bridge&quot;)<br />    ET.SubElement(root, &quot;option&quot;, gravity=&quot;0 0 -9.81&quot;)<br />    <br />    asset = ET.SubElement(root, &quot;asset&quot;)<br />    stl_files = sorted([f for f in os.listdir(mesh_dir) if f.endswith(&#39;.stl&#39;)])<br />    for i, stl_file in enumerate(stl_files):<br />        ET.SubElement(asset, &quot;mesh&quot;, name=f&quot;mesh_{i}&quot;, file=f&quot;meshes/bridge/{stl_file}&quot;, scale=&quot;0.001 0.001 0.001&quot;)<br />    <br />    worldbody = ET.SubElement(root, &quot;worldbody&quot;)<br />    bridge_body = ET.SubElement(worldbody, &quot;body&quot;, name=&quot;bridge&quot;, pos=&quot;0 0 0.15&quot;)<br />    for i in range(len(stl_files)):<br />        ET.SubElement(bridge_body, &quot;geom&quot;, name=f&quot;part_{i+1}&quot;, type=&quot;mesh&quot;, mesh=f&quot;mesh_{i}&quot;)<br />    <br />    pretty_xml = minidom.parseString(ET.tostring(root)).toprettyxml(indent=&quot;  &quot;)<br />    with open(output_file, &#39;w&#39;) as f:<br />        f.write(pretty_xml)<br />    print(f&quot;Created MuJoCo XML file: {output_file}&quot;)</pre> <h3>Step 3: Run the Process</h3> <p>Tie it all together in a main() function.</p> <pre>def main():<br />    stp_file_path = &quot;assembly/assets/ACDC_arch.stp&quot;<br />    mesh_dir = &quot;assembly/assets/meshes/bridge&quot;<br />    output_xml_file = &quot;assembly/assets/arch_bridge.xml&quot;<br />    <br />    num_parts, part_info = extract_and_convert_stp_to_stl(stp_file_path, mesh_dir)<br />    if num_parts == 0:<br />        print(&quot;Error: No parts converted. Aborting.&quot;)<br />        return<br />    <br />    create_mujoco_xml(part_info, output_xml_file, mesh_dir)<br />    print(f&quot;Conversion complete with {num_parts} parts!&quot;)</pre> <h3>The Issue: Shells vs. Solids in the STEP File</h3> <p>While working on our test file, we hit a snag: the bridge visually has 14 segments, but the code only detected 13 solids. This mismatch caused the original code to add a placeholder part, which didn’t reflect the true design.</p> <h3>Figuring Out the Problem</h3> <p>To diagnose the issue, we added logging to inspect the STEP file’s structure:</p> <ul><li>We found 13 solids, but one of them was a composite solid made up of four shells (shell_1 to shell_4).</li><li>This meant the STEP file defined the bridge as 13 solids, where the 13th solid was actually four segments combined into one. Visually, these four shells appeared as four separate segments, so the total should have been 12 (other solids) + 4 (shells) = 16 parts, not 14.</li></ul> <p>However, upon re-evaluating the visual model, we confirmed the bridge indeed has 14 segments. The discrepancy arose because the four shells were meant to be four separate solids, not one composite solid.</p> <h3>Solving the Issue</h3> <p>We used FreeCAD to fix the STEP file:</p> <ol><li><strong>Opened the STP File in FreeCAD</strong>: Identified the composite solid with four shells.</li><li><strong>Converted Shells to Solids</strong>:</li></ol> <ul><li>In the Part workbench, selected each shell (shell_1 to shell_4).</li><li>Used Part &gt; Convert to solid to turn each shell into a solid (after ensuring they were closed using the &quot;Check Geometry&quot; tool).</li><li>This gave us four new solids, replacing the composite solid.</li></ul> <ol><li><strong>Re-Exported the STP File</strong>: Saved the updated model with 14 solids (12 original + 2 new solids after combining some for the correct count).</li><li><strong>Updated the Code</strong>: Modified the code to handle both solids and shells, ensuring it could process the original file if needed, but the updated STP file now worked directly with solids.</li></ol> <p>After these changes, the code detected 14 solids, converted them to 14 STL files, and generated the MuJoCo XML without placeholders.</p> <h3>Why This Matters</h3> <p>This process bridges the gap between CAD and physics simulation:</p> <ul><li><strong>Accuracy</strong>: By fixing the shell vs. solid issue, we ensured the simulation matches the true design of the bridge.</li><li><strong>Flexibility</strong>: The code now adapts to the actual number of parts in the STEP file, avoiding arbitrary assumptions.</li><li><strong>Practicality</strong>: Using tools like FreeCAD, we can inspect and modify CAD files to fit simulation needs.</li></ul> <p>Whether you’re simulating a bridge, a robot, or any CAD model, this workflow lets you bring your designs into MuJoCo for testing. Try it with your own STEP file, and if you run into issues like shells vs. solids, FreeCAD can help you resolve them!</p> <p><img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=e034ce617c55" width="1" height="1" alt=""/></p>]]></content><author><name></name></author></entry><entry><title type="html">No planning, no execution — How to plan a perfect week</title><link href="https://stefaniezhao77.github.io/blog/2025/no-planning-no-executionhow-to-plan-a-perfect-week/" rel="alternate" type="text/html" title="No planning, no execution — How to plan a perfect week"/><published>2025-03-23T10:26:54+00:00</published><updated>2025-03-23T10:26:54+00:00</updated><id>https://stefaniezhao77.github.io/blog/2025/no-planning-no-executionhow-to-plan-a-perfect-week</id><content type="html" xml:base="https://stefaniezhao77.github.io/blog/2025/no-planning-no-executionhow-to-plan-a-perfect-week/"><![CDATA[<h3><strong>No planning, no execution — How to plan a perfect week</strong></h3> <p>Without a plan, life can slip into a foggy haze. I often find myself caught in this trap: busy all day, yet unsure what I’ve actually accomplished. When I finally get a moment to rest, I turn to social media, only to be overwhelmed by a flood of random updates — my mood shifts, my mind fills with clutter, and I end up more tired than before. Rest doesn’t feel restorative, and even after a weekend, I’m still running on empty, stuck in a loop. After exploring some books on energy management and how our minds work, I’ve learned we don’t need an overloaded schedule to change this. With just a few small, intentional adjustments — using bits of spare time — we can make our weeks feel meaningful, lift ourselves up, and give our brains a real chance to recharge.</p> <h3>1. A Daily 25-Minute Learning Block</h3> <p>Outside of work or studies, you don’t need hours — just one focused stretch, like a 25-minute Pomodoro, to explore something you’re drawn to. It’s not about assignments or job demands; it could be practicing a few phrases in a new language, reading a page or two, or diving into topics like sociology or economics — whatever lights you up. For those of us juggling busy days, where time gets sliced into fragments, this dedicated slot keeps your mind engaged. It’s also a refreshing shift in focus.</p> <h3>2. A Few Minutes for a Tiny Habit</h3> <p>Building habits is all about consistency, so start small instead of aiming big right away. Try 3 minutes of meditation, 10 minutes on guitar playing, or a 1-kilometer walk — then gently build from there. These small steps lower the hurdle to begin, and the longer you stick with it, the more you start to trust yourself, quietly boosting your confidence.</p> <h3>3. A Weekly Creative Moment</h3> <p>Each week, carve out some time to play with creativity — write a short piece, craft something by hand, sketch a drawing, or even try a new twist on a game (the “new” is key). It pulls you out of the daily slog, stirs your imagination, and lifts your spirits in a subtle way.</p> <h3>4. Time with People</h3> <p>We’re built to connect — it’s part of being human. Set aside a moment each week to catch up with old friends, meet someone new for a fresh surprise, or sit with family and talk. These real, heartfelt exchanges ease tension, offer comfort, and anchor you in the present.</p> <h3>5. Quiet Time Alone</h3> <p>Our world is noisy — voices from people nearby, online, even strangers, piling info into our heads every day. Add in the scattered thoughts and endless to-dos, and it’s a lot. That’s why we need to make space each week for solitude. It might be a walk, a few minutes staring out the window, or a chance to sift through the week’s chaos — keeping what matters, letting go of the rest.</p> <blockquote>Take It Slow, Let It Build</blockquote> <p>You might wonder, “How do I find the time?” But here’s the truth: these changes are small. No hour to spare? Try 30 minutes, 10, or even 5 — it all counts. The point isn’t to overhaul everything at once; it’s about taking that first step, giving yourself room to breathe and adjust. Don’t push for instant results or feel down if you miss a day. Perfection isn’t the goal — small, steady moves are. Start where you are, go at your pace, and time will show you what’s possible.</p> <p><img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=041e9b1698b2" width="1" height="1" alt=""/></p>]]></content><author><name></name></author></entry><entry><title type="html">Beyond the Code: The Design of the ID Anonymization Tool</title><link href="https://stefaniezhao77.github.io/blog/2025/id-anonymization-tool/" rel="alternate" type="text/html" title="Beyond the Code: The Design of the ID Anonymization Tool"/><published>2025-02-10T00:00:00+00:00</published><updated>2025-02-10T00:00:00+00:00</updated><id>https://stefaniezhao77.github.io/blog/2025/id-anonymization-tool</id><content type="html" xml:base="https://stefaniezhao77.github.io/blog/2025/id-anonymization-tool/"><![CDATA[<h2 id="the-why-a-need-for-responsible-data-handling">The “Why”: A Need for Responsible Data Handling</h2> <p>In a world increasingly driven by data, the need for responsible data handling has never been greater. I built this open-source ID anonymization tool not just as a technical exercise, but as a response to a growing ethical imperative: to protect individual privacy while still enabling valuable data analysis. Whether it’s in medical research, social science, or any field dealing with sensitive information, the ability to anonymize data effectively is crucial for maintaining public trust and complying with regulations like GDPR and HIPAA. This project is our contribution to that effort.</p> <h2 id="design-philosophy-balancing-privacy-integrity-and-usability">Design Philosophy: Balancing Privacy, Integrity, and Usability</h2> <p>From the outset, our design philosophy was guided by three core principles:</p> <ol> <li><strong>Privacy by Design:</strong> I wanted to build a tool that prioritized privacy from the ground up, not as an afterthought. This meant choosing strong cryptographic methods and ensuring that the anonymization process was irreversible.</li> <li><strong>Data Integrity:</strong> It was essential that the anonymization process did not compromise the integrity of the data itself. Researchers and analysts need to be able to trust that the underlying data remains accurate and reliable.</li> <li><strong>Usability:</strong> I aimed for a tool that was accessible to a wide range of users, not just those with deep technical expertise. This led to the development of both a graphical user interface (GUI) and a command-line interface (CLI).</li> </ol> <h2 id="anonymization-vs-utility-navigating-the-trade-offs">Anonymization vs. Utility: Navigating the Trade-offs</h2> <p>One of the central challenges in data anonymization is the inherent trade-off betIen anonymization strength and data utility. Perfect anonymization (e.g., simply deleting all identifying information) would render the data useless for most analytical purposes. Conversely, Iak anonymization (e.g., simply replacing names with pseudonyms) leaves the data vulnerable to re-identification attacks.</p> <p>I chose to use SHA-256 hashing (implemented in the <code class="language-plaintext highlighter-rouge">hash_id</code> function, lines 51-69 of <code class="language-plaintext highlighter-rouge">id_processor.py</code>) as a strong anonymization technique. SHA-256 provides a high level of security, making it computationally infeasible to reverse the hashing process. HoIver, I also recognized the need to preserve relationships <em>betIen</em> data points. This is why I implemented the mapping file concept (handled by the <code class="language-plaintext highlighter-rouge">create_id_mapping</code> function, lines 114-135 of <code class="language-plaintext highlighter-rouge">id_processor.py</code>). This allows users to define how different IDs relate to each other, ensuring that, for example, all records belonging to the same patient are linked to the same anonymized ID, even across different files.</p> <h2 id="challenges-and-solutions-a-developers-journey">Challenges and Solutions: A Developer’s Journey</h2> <p>The development process wasn’t without its hurdles. One significant challenge was ensuring data integrity and preventing file corruption, especially in the event of unexpected interruptions. I addressed this through a combination of techniques:</p> <ul> <li><strong>Automatic Backups:</strong> Before any file is modified, a backup is created (lines 249-254 of <code class="language-plaintext highlighter-rouge">id_processor.py</code>). This provides a simple but effective way to recover the original data if something goes wrong.</li> <li><strong>Temporary Files and Atomic Renames:</strong> The <code class="language-plaintext highlighter-rouge">update_file_ids</code> function (lines 137-226 of <code class="language-plaintext highlighter-rouge">id_processor.py</code>) uses a temporary file to store the updated data. Only after the entire file is successfully written is the original file replaced with the temporary file using an atomic rename operation. This minimizes the risk of data corruption.</li> <li><strong>Retry Logic:</strong> I also incorporated retry logic (lines 190-209 of <code class="language-plaintext highlighter-rouge">id_processor.py</code>) to handle situations where the file might be temporarily locked by another process.</li> </ul> <p>Another challenge was handling potentially malformed or inconsistent input data. The <code class="language-plaintext highlighter-rouge">read_file</code> function (lines 70-84 of <code class="language-plaintext highlighter-rouge">id_processor.py</code>) includes error handling to gracefully manage various file formats and potential issues. I also added checks to ensure that the mapping file itself is valid and contains the required columns (lines 289-291 of <code class="language-plaintext highlighter-rouge">id_processor.py</code>).</p>]]></content><author><name></name></author><category term="Tools"/><category term="python"/><category term="data-anonymization"/><summary type="html"><![CDATA[The “Why”: A Need for Responsible Data Handling]]></summary></entry></feed>