<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"> <html><body> <p>Simulating a 3D CAD model in a physics engine like MuJoCo can be a powerful way to test designs in a virtual environment. However, MuJoCo doesn’t directly understand CAD formats like STEP (STP) files — it needs STL meshes and an XML file to define the simulation. In this blog, I’ll walk you through the process of converting a STEP file into a MuJoCo XML file using Python, focusing on the key steps, the reasoning behind them, and a real-world issue we encountered with shells and solids. Let’s get started!</p> <h3>Why Do This?</h3> <p>MuJoCo is a physics engine used for robotics, animation, and engineering simulations. It requires:</p> <ul> <li> <strong>STL Files</strong>: Triangle meshes that represent the 3D geometry of each part.</li> <li> <strong>XML File</strong>: A configuration file that links the STL meshes, defines their positions, and sets simulation properties like gravity and mass.</li> </ul> <p>A STEP file, on the other hand, is a standard CAD format (ISO 10303) that stores precise 3D geometry using mathematical definitions (e.g., surfaces, solids). To use it in MuJoCo, we need to:</p> <ol> <li>Extract the parts from the STEP file.</li> <li>Convert them to STL meshes.</li> <li>Create an XML file to tie everything together for simulation.</li> </ol> <p>This process lets us take a CAD design — like our arch bridge — and simulate its physical behavior, such as how it handles stress or movement.</p> <h3>Key Terms: Understanding the STEP File</h3> <p>Before diving in, let’s clarify some terms you’ll encounter in a STEP file:</p> <ul> <li> <strong>Solid</strong>: A fully enclosed 3D volume with a defined interior, like a solid block or a closed frame. Solids are ideal for physics simulations because they have mass and volume.</li> <li> <strong>Shell</strong>: A collection of connected faces forming a surface, like the “skin” of an object. Shells don’t have an interior unless they’re part of a solid. They’re often used for thin-walled structures or reference geometry.</li> <li> <strong>Compound</strong>: A group of shapes (solids, shells, etc.) treated as a single entity in the STEP file. For example, a bridge might be a compound of multiple solids.</li> </ul> <p>In our case, the ACDC_arch.stp file represents an arch bridge, which we expected to have 14 distinct segments (parts). However, as we’ll see, the STEP file’s structure caused an issue that we needed to resolve.</p> <h3>Tools You’ll Need</h3> <ul> <li> <strong>Python</strong>: Version 3.6+.</li> <li> <strong>Libraries</strong>:</li> <li> <strong>pythonocc-core</strong>: Reads STEP files and converts them to STL meshes.</li> <li> <strong>numpy</strong>: Handles numerical data for mesh creation.</li> <li> <strong>stl</strong>: Saves meshes as STL files.</li> <li> <strong>xml.etree.ElementTree</strong>: Builds the MuJoCo XML file.</li> <li> <strong>FreeCAD</strong>: A free CAD tool to inspect and modify the STEP file if needed.</li> </ul> <p>Install the Python libraries:</p> <pre>pip install pythonocc-core numpy stl</pre> <h3>The Overall Process: Steps and Why</h3> <p>Here’s the high-level process to convert the STEP file to MuJoCo XML, along with why each step matters:</p> <p><strong>Extract Parts from the STEP File</strong>:</p> <ul> <li> <strong>Why</strong>: A STEP file can contain multiple parts (solids, shells, etc.), and we need to identify each one to convert it to STL. For our bridge, we expected 14 parts (one for each segment).</li> <li> <strong>How</strong>: Use pythonocc-core to read the STEP file and extract solids.</li> </ul> <p><strong>Convert Parts to STL Files</strong>:</p> <ul> <li> <strong>Why</strong>: MuJoCo needs STL files (triangle meshes) to render and simulate the geometry. STEP files use mathematical surfaces, which MuJoCo can’t directly use.</li> <li> <strong>How</strong>: Tessellate each part into a mesh and save it as an STL file.</li> </ul> <p><strong>Generate the MuJoCo XML File</strong>:</p> <ul> <li> <strong>Why</strong>: The XML file tells MuJoCo where to place each part, how they interact, and other simulation settings.</li> <li> <strong>How</strong>: Create an XML structure that references the STL files and defines the simulation environment.</li> </ul> <h3>The Code: Key Steps</h3> <p>Here’s the simplified code to achieve this, focusing on the main ideas.</p> <h3>Step 1: Extract and Convert to STL</h3> <p>We use pythonocc-core to read the STEP file, extract solids, and convert them to STL files.</p> <pre>import os<br>from OCC.Core.STEPControl import STEPControl_Reader<br>from OCC.Core.TopExp import TopExp_Explorer, TopAbs_SOLID<br>from OCC.Core.BRepMesh import BRepMesh_IncrementalMesh<br>from OCC.Core.StlAPI import StlAPI_Writer<br>from OCC.Core.TopoDS import topods</pre> <pre>def extract_and_convert_stp_to_stl(stp_file_path, output_dir):<br>    os.makedirs(output_dir, exist_ok=True)<br>    step_reader = STEPControl_Reader()<br>    step_reader.ReadFile(stp_file_path)<br>    step_reader.TransferRoots()<br>    <br>    all_solids = []<br>    part_info = []<br>    for i in range(1, step_reader.NbRootsForTransfer() + 1):<br>        shape = step_reader.Shape(i)<br>        explorer = TopExp_Explorer(shape, TopAbs_SOLID)<br>        while explorer.More():<br>            solid = topods.Solid(explorer.Current())<br>            if solid not in all_solids:<br>                all_solids.append(solid)<br>                part_info.append({'id': len(all_solids), 'name': f'part_{len(all_solids)}'})<br>            explorer.Next()<br>    <br>    print(f"Detected {len(all_solids)} solids in the STEP file")<br>    <br>    successful_conversions = 0<br>    for i, solid in enumerate(all_solids):<br>        try:<br>            mesh = BRepMesh_IncrementalMesh(solid, 0.01)<br>            mesh.Perform()<br>            if not mesh.IsDone():<br>                continue<br>            stl_writer = StlAPI_Writer()<br>            stl_file = os.path.join(output_dir, f"part_{i+1}.stl")<br>            stl_writer.Write(solid, stl_file)<br>            successful_conversions += 1<br>            print(f"Created {stl_file}")<br>        except Exception as e:<br>            print(f"Error processing part_{i+1}: {e}")<br>    <br>    return successful_conversions, part_info[:successful_conversions]</pre> <h3>Step 2: Generate MuJoCo XML</h3> <p>We create an XML file that references the STL files and sets up the simulation.</p> <pre>import xml.etree.ElementTree as ET<br>import xml.dom.minidom as minidom<br>import os</pre> <pre>def create_mujoco_xml(part_info, output_file, mesh_dir):<br>    root = ET.Element("mujoco", model="arch_bridge")<br>    ET.SubElement(root, "option", gravity="0 0 -9.81")<br>    <br>    asset = ET.SubElement(root, "asset")<br>    stl_files = sorted([f for f in os.listdir(mesh_dir) if f.endswith('.stl')])<br>    for i, stl_file in enumerate(stl_files):<br>        ET.SubElement(asset, "mesh", name=f"mesh_{i}", file=f"meshes/bridge/{stl_file}", scale="0.001 0.001 0.001")<br>    <br>    worldbody = ET.SubElement(root, "worldbody")<br>    bridge_body = ET.SubElement(worldbody, "body", name="bridge", pos="0 0 0.15")<br>    for i in range(len(stl_files)):<br>        ET.SubElement(bridge_body, "geom", name=f"part_{i+1}", type="mesh", mesh=f"mesh_{i}")<br>    <br>    pretty_xml = minidom.parseString(ET.tostring(root)).toprettyxml(indent="  ")<br>    with open(output_file, 'w') as f:<br>        f.write(pretty_xml)<br>    print(f"Created MuJoCo XML file: {output_file}")</pre> <h3>Step 3: Run the Process</h3> <p>Tie it all together in a main() function.</p> <pre>def main():<br>    stp_file_path = "assembly/assets/ACDC_arch.stp"<br>    mesh_dir = "assembly/assets/meshes/bridge"<br>    output_xml_file = "assembly/assets/arch_bridge.xml"<br>    <br>    num_parts, part_info = extract_and_convert_stp_to_stl(stp_file_path, mesh_dir)<br>    if num_parts == 0:<br>        print("Error: No parts converted. Aborting.")<br>        return<br>    <br>    create_mujoco_xml(part_info, output_xml_file, mesh_dir)<br>    print(f"Conversion complete with {num_parts} parts!")</pre> <h3>The Issue: Shells vs. Solids in the STEP File</h3> <p>While working on our test file, we hit a snag: the bridge visually has 14 segments, but the code only detected 13 solids. This mismatch caused the original code to add a placeholder part, which didn’t reflect the true design.</p> <h3>Figuring Out the Problem</h3> <p>To diagnose the issue, we added logging to inspect the STEP file’s structure:</p> <ul> <li>We found 13 solids, but one of them was a composite solid made up of four shells (shell_1 to shell_4).</li> <li>This meant the STEP file defined the bridge as 13 solids, where the 13th solid was actually four segments combined into one. Visually, these four shells appeared as four separate segments, so the total should have been 12 (other solids) + 4 (shells) = 16 parts, not 14.</li> </ul> <p>However, upon re-evaluating the visual model, we confirmed the bridge indeed has 14 segments. The discrepancy arose because the four shells were meant to be four separate solids, not one composite solid.</p> <h3>Solving the Issue</h3> <p>We used FreeCAD to fix the STEP file:</p> <ol> <li> <strong>Opened the STP File in FreeCAD</strong>: Identified the composite solid with four shells.</li> <li> <strong>Converted Shells to Solids</strong>:</li> </ol> <ul> <li>In the Part workbench, selected each shell (shell_1 to shell_4).</li> <li>Used Part &gt; Convert to solid to turn each shell into a solid (after ensuring they were closed using the "Check Geometry" tool).</li> <li>This gave us four new solids, replacing the composite solid.</li> </ul> <ol> <li> <strong>Re-Exported the STP File</strong>: Saved the updated model with 14 solids (12 original + 2 new solids after combining some for the correct count).</li> <li> <strong>Updated the Code</strong>: Modified the code to handle both solids and shells, ensuring it could process the original file if needed, but the updated STP file now worked directly with solids.</li> </ol> <p>After these changes, the code detected 14 solids, converted them to 14 STL files, and generated the MuJoCo XML without placeholders.</p> <h3>Why This Matters</h3> <p>This process bridges the gap between CAD and physics simulation:</p> <ul> <li> <strong>Accuracy</strong>: By fixing the shell vs. solid issue, we ensured the simulation matches the true design of the bridge.</li> <li> <strong>Flexibility</strong>: The code now adapts to the actual number of parts in the STEP file, avoiding arbitrary assumptions.</li> <li> <strong>Practicality</strong>: Using tools like FreeCAD, we can inspect and modify CAD files to fit simulation needs.</li> </ul> <p>Whether you’re simulating a bridge, a robot, or any CAD model, this workflow lets you bring your designs into MuJoCo for testing. Try it with your own STEP file, and if you run into issues like shells vs. solids, FreeCAD can help you resolve them!</p> <p><img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=e034ce617c55" width="1" height="1" alt=""></p> </body></html>